{"version":3,"sources":["components/card/card.component.jsx","components/card_list/card_list.component.jsx","components/search_box/search_box.component.jsx","App.js","serviceWorker.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","key","SearchBox","type","placeholder","onChange","handleChange","App","state","searchField","e","setState","target","value","fetch","then","response","json","users","this","filteredMonsters","filter","toLowerCase","includes","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"mVA4BaA,G,kBAAO,SAAEC,GAAF,OAEhB,yBAAKC,UAAU,kBAEX,yBAAKC,IAAI,UAAUC,IAAG,+BAA2BH,EAAMI,QAAQC,GAAzC,eACtB,4BAAML,EAAMI,QAAQE,MACpB,2BAAKN,EAAMI,QAAQG,UCtBdC,EAAW,SAAER,GAAF,OA2BpB,yBAAKC,UAAU,aAEPD,EAAMS,SAASC,KAAK,SAAEN,GAAF,OAChB,kBAAC,EAAD,CAAMO,IAAMP,EAAQC,GAAKD,QAAUA,SC1BtCQ,G,MAAY,SAAEZ,GAAF,OACrB,2BACIC,UAAY,SACZY,KAAY,SACZC,YAAcd,EAAMc,YACpBC,SAAcf,EAAMgB,iBC4UbC,E,2MA5TXC,MAAQ,CACJT,SAAc,GACdU,YAAc,I,EA+GlBH,aAAe,SAAEI,GACb,EAAKC,SAAU,CAAEF,YAAcC,EAAEE,OAAOC,S,mFA1FvB,IAAD,OAiEhBC,MAAO,8CACNC,MAAM,SAAEC,GAAF,OAAgBA,EAASC,UAC/BF,MAAM,SAAKG,GAAL,OAAgB,EAAKP,SAAU,CAAEZ,SAAWmB,S,+BA4B9C,MAqJ6BC,KAAKX,MAA/BT,EArJH,EAqJGA,SAAUU,EArJb,EAqJaA,YACZW,EAAmBrB,EAASsB,QAAQ,SAAE3B,GAExC,OAAOA,EAAQE,KAAK0B,cAAcC,SAAUd,EAAYa,kBA8B5D,OACI,yBAAK/B,UAAU,OACX,gDACA,kBAAC,EAAD,CACIa,YAAY,iBACZE,aAAea,KAAKb,eAExB,kBAAC,EAAD,CAAUP,SAAWqB,S,GAlUnBI,aCXEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMrB,MAAK,SAAAsB,GACjCA,EAAaC,kB","file":"static/js/main.7f0a0595.chunk.js","sourcesContent":["\n// first import React\nimport React from 'react';\nimport './card.styles.css';\n\n// next, we will export the \" Card \" functional component and then we will implicitly return some\n// jsx and we pass in the props object and that props object is being passed down from the\n// card-list.component.jsx file where monster={ monster } so props.monster in this file gives us\n// access to one monster object and all of its key value pairs\n\n// in other words, were passing monster into the Card component from the card-list.component.jsx\n// file and in the Card component gets access to monster from the props object and then displays\n// the monster's name and now let's add the styling to make it look closer to our final app and\n// first make a new file inside the card folder called card.styles.css and then we use the\n// card-container class styles inside our div tag below and remember to import the stylesheet\n// above or import the card.styles.css file above\n\n// now where do we get the image? we get the images from a site called robo hash and each time\n// you pass a different number to the url you get a different monster image so add an image tag\n// below and remember \" set=set2 \" is a URL parameter and what it is saying essentially is use\n// this set of images and all this information is on the robo hash website and let's add another\n// parameter and we do that by adding \" &size=180x180 \" but I left the size parameter off since\n// it was skewing the images and they are now showing up at 477x300 and if we go to our site we\n// see that the monster images are displaying correctly and our site is now looks really close\n// to our final application\n\n// now let's add an email for each monster and in the next section we will add the search bar\n// and we will see how we can filter out monsters and add more functionality to our components\nexport const Card = ( props ) => (\n\n    <div className=\"card-container\">\n\n        <img alt=\"monster\" src={ `https://robohash.org/${props.monster.id}?set=set2` } />\n        <h2>{ props.monster.name }</h2>\n        <p>{ props.monster.email }</p>\n\n    </div>\n\n);\n","\nimport React from 'react';\nimport './card_list.styles.css';\n\n// -- Mark 1 --\n// lecture 29: Card Component\nimport { Card } from '../card/card.component';\n// End of -- Mark 1 --\n\n// we will make a functional component for this file and one of the big things about components\n// is that they take in something called props and our arrow function will have an argument\n// or parameter called props \nexport const CardList = ( props ) => (\n\n    // for now, let's console.log out \" props \"\n    // console.log( props );\n\n    // let's add a className to the div tag below\n\n    // -- Mark 1 --\n    // lecture 29: Card Component\n    // coming from App.js and remove \" props.children \" below and replace it with:    \n    /*\n    { props.monsters.map( ( monster ) => (\n        <h1 key={ monster.id }> { monster.name } </h1>\n    ) ) }\n    */\n    \n    // so we want the map functionality in this file not App.js but what the CardList is not going\n    // to be responsible for is deciding how this component will look and we will make new\n    // component to handle the individual cards and first make a \" card \" folder in our component\n    // folder and then make a \" card.component.jsx \" file inside our card folder and then go to\n    // the -- card.component.jsx -- file and were back from the -- card.component.jsx -- file and\n    // change \"  <h1 key={ monster.id }>{ monster.name }</h1> \" to\n    // \" <Card key={ monster.id } monster={ monster } /> \" and then go the -- card.component.jsx --\n    // file\n    \n    // End of -- Mark 1 --\n\n    <div className=\"card-list\">\n        { \n            props.monsters.map( ( monster ) => (\n                <Card key={ monster.id } monster={ monster } />\n            ) )\n        }\n    </div>\n\n    // now import our named export above or CardList to App.js\n    // go to -- App.js -- Mark 4 --\n\n);\n\n","\nimport React from 'react';\nimport './search_box.styles.css';\n\n// create a functional component\n// functional components unlike class components don't have access to state and don't have access\n// to lifecycle methods and we don't always need internal state or lifecycle methods and sometimes\n// all we want to do is render some html so a functional component is a component that gets some\n// props and returns html and if we don't think we need access to state or lifecycle methods then\n// just use a functional component\n\n// so let's copy our input element from App.js and place it inside our arrow function below and\n// make the placeholder attribute dynamic since we may want to reuse this component and we could\n// have destructured the props object and pulled off the placeholder and handleChange properties\n// so that the argument would be ( { placeholder, handleChange } ) instead of ( props )\n// go to -- Mark 8 -- in App.js\nexport const SearchBox = ( props ) => (\n    <input\n        className  =\"search\"\n        type       =\"search\"\n        placeholder={ props.placeholder }\n        onChange   ={ props.handleChange }\n    />\n);\n\n\n// alternative 1 to the above code:\n/*\nexport const SearchBox = ( { placeholder, handleChange } ) => (\n    <input\n        className  =\"search\"\n        type       =\"search\"\n        placeholder={ placeholder }\n        onChange   ={ handleChange }\n    />\n);\n*/\n","\n// -- Mark 1 --\n// lecture 20: Class Components\n// first, let's import Component from React\n// End of -- Mark 1 --\nimport React, { Component } from 'react';\n// were not using the logo anymore so let's comment it out\n// import logo from './logo.svg';\nimport './App.css';\n// -- Mark 4 --\n// lecture 28: Card List Component\n// import our CardList component\nimport { CardList } from './components/card_list/card_list.component';\n// End of -- Mark 4 --\n// -- Mark 8 --\n// lecture 36: Search Box Component\nimport { SearchBox } from './components/search_box/search_box.component';\n// End of -- Mark 8 --\n\n// -- Mark 1 -- continued\n// lecture 20: Class Components\n// convert our initial function below into a class\n// End of -- Mark 1 --\nclass App extends Component {\n\n    // -- Mark 1 -- continued\n    // lecture 20: Class Components        \n    // I commented out the constructor method below and just called state directly and I\n    // could do this since create react app comes pre built with the babel tranform class\n    // properties plugin so we can define key value pairs inline like I did with \" state \"\n    // below\n\n    // -- Mark 2 --\n    // lecture 22: Dynamic Content\n    // change state below by creating a new property called \" monsters \" and we will make it\n    // equal an array of objects\n    // End of -- Mark 2 --\n    state = {\n        monsters    : [],\n        searchField : ''\n    };\n\n    /*\n    constructor() {\n        super();\n\n        this.state = {\n            string : 'Hello Yihua'\n        };\n    }\n    */\n   // End of -- Mark 1 --\n\n\n    // -- Mark 3 --\n    // lecture 25: Fetching Content\n    // remember, Component gives us a bunch of other methods called lifecycle methods and what are\n    // lifecycle methods? they are methods that get called at different stages as a component gets\n    // rendered amd we want to focus on componentDidMount and componentDidMount happens when the\n    // components mounts or when react renders our component to the DOM for the first time and when\n    // this happens it will call whatever block of code is inside the componentDidMount method\n    componentDidMount() {\n        // what we want to do inside componentDidMoount is use JavaScript's native fetch() to make\n        // a request from the URL and what fetch returns is a promise and then we can do something\n        // with that promise and the promise will give us a response argument and when we log out\n        // the response ( i.e. console.log( response ) ) we get back the following:\n        /*\n        Response {type: \"cors\", url: \"https://jsonplaceholder.typicode.com/users\", redirected: false, status: 200, ok: true, …}\n        body: ReadableStream\n        bodyUsed: false\n        headers: Headers {}\n        ok: true\n        redirected: false\n        status: 200\n        statusText: \"OK\"\n        type: \"cors\"\n        url: \"https://jsonplaceholder.typicode.com/users\"\n            __proto__: Response\n        */\n\n        // and what we want is located inside the body property but we need it in a format that\n        // JavaScript can understand and response.json() will parse the response as JSON\n        // or convert the response into the format JSON and by returning\n        // response.json() we create a new promise and we can then use this new promise and this\n        // new promise will contain data that JavaScript can understand or this new promise will\n        // contain the body of our users array and let's console.log out \" users \" so we can see\n        // what were getting ( i.e. console.log( users ) ) and we get back the following:\n        /*\n        (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]\n        0: {id: 1, name: \"Leanne Graham\", username: \"Bret\", email: \"Sincere@april.biz\",\n        1: {id: 2, name: \"Ervin Howell\", username: \"Antonette\", email: \"Shanna@melissa.tv\",\n        2: {id: 3, name: \"Clementine Bauch\", username: \"Samantha\", email: \"Nathan@yesenia.net\",\n        3: {id: 4, name: \"Patricia Lebsack\", username: \"Karianne\", email: \"Julianne.OConner@kory.org\",\n        4: {id: 5, name: \"Chelsey Dietrich\", username: \"Kamren\", email: \"Lucio_Hettinger@annie.ca\",\n        5: {id: 6, name: \"Mrs. Dennis Schulist\", username: \"Leopoldo_Corkery\", email: \"Karley_Dach@jasper.info\",\n        6: {id: 7, name: \"Kurtis Weissnat\", username: \"Elwyn.Skiles\", email: \"Telly.Hoeger@billy.biz\",\n        7: {id: 8, name: \"Nicholas Runolfsdottir V\", username: \"Maxime_Nienow\", email: \"Sherwood@rosamond.me\",\n        8: {id: 9, name: \"Glenna Reichert\", username: \"Delphine\", email: \"Chaim_McDermott@dana.io\",\n        9: {id: 10, name: \"Clementina DuBuque\", username: \"Moriah.Stanton\", email: \"Rey.Padberg@karina.biz\",\n            length: 10\n            __proto__: Array(0)\n        */\n\n        // so we can use this array and now we want to call setState inside this promise or inside\n        // our then() call and we want to set our monsters equal to this array of users so now we\n        // want our monsters property inside the initial state to be equal to an empty array since\n        // we no longer need to hardcode the array so now were going to wait for our component to\n        // mount and then were going to fetch all of our users and then update our state monster's\n        // property with this new array of users and if we go check our application or website\n        // we see that we now have all 10 monsters or users listed on the page as follows:\n\n        /*\n        Leanne Graham\n        Ervin Howell\n        Clementine belly\n        Patricia Lebsack\n        Chelsey Dietrich\n        Mrs. Dennis Schulist\n        Kurtis Weissnat\n        Nicholas Runolfsdottir V\n        Glenna Reichert\n        Clementina DuBuque\n        */\n\n        // in the next section, we are going to convert our list of users on our website to look\n        // a little bit more like our finished monsters website\n        fetch( 'https://jsonplaceholder.typicode.com/users' )\n        .then( ( response ) => response.json() )\n        .then( (    users ) => this.setState( { monsters : users } ) );\n    }\n    // End of -- Mark 3 --\n  \n\n    // -- Mark 9 --\n    // lecture 38: Class Methods and Arrow Functions\n    // if we were to write this as a class method then handleChange would look as follow below\n    // and we would change\n    // \" handleChange={ ( e ) => this.setState( { searchField : e.target.value } ) } \" to\n    // \" handleChange={ this.handleChange } \"\n    // but if we save this file and view the site we will see that this is undefined and why is\n    // this? because in JavaScript we have to explicitly state what the context of \" this \" should\n    // be and we don't do that when we use a class method but we could make it work by typing\n    // \" this.handleChange = this.handleChange.bind( this ); \" inside the contructor method but\n    // this way of doing things is a very verbose way of writing code and we can avoid this by\n    // using es6 arrow functions and arrow functions set the context of \" this \" in whatever it\n    // was that declared it in the first place and when JavaScript runs our component the\n    // component will be the environment in which handleChange, in our example below, was declared\n    // and therefore the \" this \" keyword inside handleChange will be bound to our component\n    // so arrow functions always set the correct binding for the \" this \" keyword, therefore, let's\n    // change handleChange to an equal an arrow function and now the site will work as expected\n    handleChange = ( e ) => {\n        this.setState( { searchField : e.target.value } )       \n    }\n    // End of -- Mark 9 --\n\n\n    render() {\n        // -- Mark 1 -- continued\n        // lecture 20: Class Components        \n        // the render method returns any html we want and let's return the html we had before\n        // inside our function and we see that the webpage looks exactly the same as before when\n        // we were using a function to return html\n\n        // by using a class component we get access to this thing called state and state is a js\n        // object with properties that we can access at anytime inside our class and the way we\n        // would do this is by calling the constructor keyword and inside constructor we want to\n        // call super() and super calls the constructor method on the Component class and this\n        // gives us access to this.state and we can set it to something ( see above ) and now we\n        // can render that string down below by typing \" { this.state.string } \" and jsx tells html\n        // that anything between the curly braces will be JavaScript and we use \n        // \" { this.state.string } \" in multiple places which is great\n\n        // if we wanted to change the state, Component gives us a method called setState and\n        // setState let's us modify our state object and we also have access to a property called\n        // onClick that takes a function that gets called whenever the corresponding element gets\n        // clicked or in our case whenever the button is clicked and will use the setState method\n        // below to change the state and that is great because it gives us a lot of control over\n        // what our components will display\n        // End of -- Mark 1 --\n\n        // -- Mark 2 -- continued\n        // lecture 22: Dynamic Content\n        // remove all the jsx between the div with the className of App and replace it as follows:\n\n        // -- Mark 4 --\n        // lecture 28: Card List Component\n        // place the CardList component below and the props parameter in CardList will be equal to\n        // an object that contains the key value pairs that we pass into CardList so if we say\n        // \" name = James \" inside our CardList component below, we will see the following in \n        // console ( remember in CardList we consoled out props or did console.log( props ); ):\n        /*\n        {name: \"James\"}\n        {name: \"James\"}\n        */\n\n        // and one of the main properties that exist on the props object is called children and\n        // children are what you pass in between a component or in between\n        // <CardList></CardList> so if we say <CardList>Mike</CardList> then the children prop\n        // will be \" Mike \" so try this below and the go to -- card-list.component.jsx -- and change\n        // \" return <div>Hello</div> \" to \" return <div>{ props.children }</div> \" and the result\n        // will be shown on the webpage as:\n        /*\n        Mike\n        */\n\n        // and we also have access to props in our App component and now let's focus on our css\n        // file and go to -- card-list.styles.css -- and now were back from\n        // -- card-list.styles.css -- and let's move </CardList> down so that it now includes the\n        // monsters array and take out \" Mike \" so now props.children in the CardList component\n        // will include all the monsters and they will be laid out in an equal grid per our style\n        // sheet or card-list.styles.css\n\n        // so this is a fundalmental principal of react, we are building components that only care\n        // about one thing and our CardList component only cares about displaying cards and in the\n        // next lesson we will take this ideas a step further and apply it to an individual card\n        // component\n        // End of -- Mark 4 --\n\n        // -- Mark 5 --\n        // lecture 29: Card Component\n        // first, delete \" name = 'James' \" in <CardList> and then pass in a prop we can use in the\n        // CardList component and that prop along with the corresponding value will be\n        // \" monsters={ this.state.monsters } \" and we move\n        // \" this.state.monsters.map( ( monster ) => <h1 key={ monster.id }>{ monster.name }</h1> ) \"\n        // into the CardList component and go to the CardList component -- Mark 1 --\n        // End of -- Mark 5 --\n\n        // -- Mark 6 --\n        // lecture 32: SearchField State\n        // add an input element below and make the type equal to \" search \" and then give the\n        // element a placeholder attribute equal to \" search monsters \" so now what we need to do\n        // is be able to take the typed input string and store the string into our state object and\n        // by storing the string in state we are able to use it to filter out our monsters so first\n        // we need to figure out how to store the string in our state object and let's add a key\n        // value pair to our state object and call the key \" searchField \" and leave the value\n        // equal to an empty string for now and let's add an onChange event handler to our input\n        // element and then use setState to change our searchField value within our state object \n        // to equal whatever value the user types into the input element\n\n        // asynchrosnous versus synchronous is a big thing in JavaScript development right now and\n        // a big thing in reach as well and sychronous action is something we can expect to happen\n        // almost immediately and with sychronous events JavaScript will wait until that action has\n        // completed before moving to the rest of the code but with an asynchronous action or event\n        // is something that takes an indefinite amount of time and JavaScript does not know how\n        // long it will take to complete the asynchronous action or event so what happens is\n        // that JavaScript will continue running the rest of the code and then when the ayschronous\n        // event finishes then JavaScript will run that asynchronous event so the main takeaway\n        // here is that setState is not happening immediately or when we would expect it to and\n        // therefore setState is always one character behind where it should be in this particular\n        // instance so the solution to this predicament is to use a second argument to setState\n        // which will be an arrow function and this function will run after setState has updated\n        // the searchField state\n\n        // remember, if we want to see or do something with our state right after we set it then\n        // we have to do it inside the second argument to the setState() call and this second\n        // argument function will get called right after the first argument function has completed\n        // in setState and now onChange looks like the following:\n        /*\n        onChange =\n        { \n            ( e ) => {\n                this.setState( \n                    { searchField : e.target.value },\n                    () => console.log( this.state )                            \n                )\n            } \n        }\n        */\n\n        // now that we have our searchField being stored let's filter out our monsters but first\n        // let's remove our second argument to setState or \" () => console.log( this.state ) \"\n        // and onto the next video\n        // End of -- Mark 6 --\n\n        // -- Mark 7 --\n        // lecture 34: Filtering State\n        // remember, we don't want to modify our state's monster array in case we need it later\n        // or somewhere else in this component so what we'll do is make a new array using the\n        // filter method but first let's destructure the state object and what destructuring allows\n        // us to do is pull properties off an object and set these properties equal to constants\n        // and we put these properties inside the curly braces and set it equal to the object we\n        // want to destructure from and when use the following syntax:\n        // \" const { monsters, searchField } = this.state; \"  we are saying that we want to pull\n        // the monsters and searchField values off of the state object and setting them as\n        // constants called monsters and searchField and this is equal to:\n        // const monsters = this.state.monsters; and\n        // const searchField = this.state.searchField;\n\n        // now let's set a new const called filteredMonster and set it equal to\n        // \" monsters.filter( ( monster ) => monster.name.toLowerCase().includes(\n        // searchField.toLowerCase() ) ); \" and the\n        // includes method checks to see whether the string value we pass to includes is found\n        // in monster.name.toLowerCase() and if that is true then that monster will be added to the\n        // new filters array and if false then that monster will not be added to the new filters\n        // array and instead of using \" { this.state.monsters } \" in our CardList component we will\n        // use filteredMonsters instead or \"<CardList monsters={ filteredMonsters } />\" and\n        // filteredMonsters is just a new monsters array that has been filtered and remember that\n        // whenever setState is called because our searchField property has changed then react will\n        // rerender our component and when the component rerenders then filteredMonsters is called\n        // again creating a new array and this new array is feed into the CardList component which\n        // will then rerender our CardList component which will then rerender our Card component\n        // and this is what is great about react because react is able to take control over what\n        // to render and rerender in our application without us having to do a bunch of extensive\n        // calls to show elements, hide elements, etc.\n\n        const { monsters, searchField } = this.state;\n        const filteredMonsters = monsters.filter( ( monster ) => {\n\n            return monster.name.toLowerCase().includes( searchField.toLowerCase() )\n\n        } );\n        // End of -- Mark 7 --\n\n        // -- Mark 8 --\n        // lecture 36: Search Box Component\n        // change the input element below into <SearchBox ... />\n        // now go the website and test it and we see that our funtionality is working fine but\n        // now we have a reuseable component ( i.e. SearchBox ) that we can use in multiple places\n        // and this is what is great about react is this component style of writing code so our\n        // SearchBox component is a presentational component that styles an input field within our\n        // app and it takes in any funtionality it might need by using the handleChange property\n        // that is being passed down to the SeachBox component from App.js or the App component\n        // so again one of the huge advantages to using react is this idea of writing these smaller\n        // and smaller reusable components\n        // End of -- Mark 8 --\n\n        // -- Mark 10 --\n        // lecture 43: Deploying Our App\n        // let's add am h1 tag above the SearchBox component and we need to import the Google font\n        // for \" Monsters Rolodex \" and go to Google fonts and search for Bigelow Rules and copy\n        // the link for the font into the <head></head> of our index.html file and then go to\n        // App.css and add a new rule for our h1 tag and then go to index.css and add a new\n        // background color to the body element and remember that index.css is a file that gets\n        // generated by create react app and now our project is finished\n\n        // so we've built a project that has filtering and we understand how components are created\n        // End of -- Mark 10 --\n\n        return (\n            <div className=\"App\">\n                <h1>Monsters Rolodex</h1>\n                <SearchBox \n                    placeholder='seach monsters'\n                    handleChange={ this.handleChange }\n                />\n                <CardList monsters={ filteredMonsters } />\n            </div>\n        );\n    }\n\n}\n\n\nexport default App;\n\n// -- Mark 1 -- continued\n// lecture 20: Class Components\n// comment out the function below\n/*\nfunction App() {\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <img src={ logo } className=\"App-logo\" alt=\"logo\" />\n                <p>Edit <code>src/App.js</code> and save to reload.</p>\n                <a\n                    className=\"App-link\"\n                    href=\"https://reactjs.org\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                Learn React\n                </a>\n            </header>\n        </div>\n    );\n}\n*/\n// End of -- Mark 1 --\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n        \n"],"sourceRoot":""}